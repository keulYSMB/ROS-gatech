#!/usr/bin/env python
import roslib; roslib.load_manifest('rover_driver_base')
import rospy
from geometry_msgs.msg import Twist
import numpy
from numpy.linalg import pinv
from math import atan2, hypot, pi, cos, sin
import time
import decimal

prefix=["FL","FR","CL","CR","RL","RR"]

class RoverMotors:
    def __init__(self):
        self.steering={}
        self.drive={}
        for k in prefix:
            self.steering[k]=0.0
            self.drive[k]=0.0
    def copy(self,value):
        for k in prefix:
            self.steering[k]=value.steering[k]
            self.drive[k]=value.drive[k]

class DriveConfiguration:
    def __init__(self,radius,x,y,z):
        self.x = x
        self.y = y
        self.z = z
        self.radius = radius

class RoverKinematics:
    def __init__(self):
        self.X = numpy.asmatrix(numpy.zeros((3,1)))
	self.displacement = numpy.asmatrix(numpy.zeros((3,1)))
	self.A = numpy.asmatrix(numpy.zeros((12,3)))
	self.B = numpy.asmatrix(numpy.zeros((12,1)))
        self.motor_state = RoverMotors()
        self.first_run = True
	self.previousTime = time.time()
	self.currentTime = time.time()

    def drem(self, x,y):
	xd = decimal.Decimal(x)
	yd = decimal.Decimal(y)
	return float(xd.remainder_near(yd))

    def twist_to_motors(self, twist, drive_cfg, skidsteer=False):
        motors = RoverMotors()
	self.twist = twist
        if skidsteer:
            for k in drive_cfg.keys():
                # Insert here the steering and velocity of 
                # each wheel in skid-steer mode
                motors.steering[k] = 0
                motors.drive[k] =  twist.linear.x-twist.angular.z*drive_cfg[k].y
        else:
            for k in drive_cfg.keys():
                # Insert here the steering and velocity of 
                # each wheel in rolling-without-slipping mode
                motors.steering[k] = atan2(twist.linear.y+twist.angular.z*drive_cfg[k].x,twist.linear.x-twist.angular.z*drive_cfg[k].y)
                motors.drive[k] = hypot(twist.linear.x-twist.angular.z*drive_cfg[k].y,twist.linear.y+twist.angular.z*drive_cfg[k].x)/drive_cfg[k].radius
		#goal= atan2(twist.linear.y+twist.angular.z*drive_cfg[k].x,twist.linear.x-twist.angular.z*drive_cfg[k].y)
		#velocity = 	hypot(twist.linear.x-twist.angular.z*drive_cfg[k].y,twist.linear.y+twist.angular.z*drive_cfg[k].x)/drive_cfg[k].radius
	#	if(twist.linear.x>0):
			
	#		if(motors.steering[k]-goal>pi/2):
	#			motors.steering[k]=(pi-goal)
	#			motors.drive[k]=-velocity
	#		elif(motors.steering[k]-goal<-pi/2):
	#			motors.steering[k]=(goal-pi)
	#			motors.drive[k]=-velocity
#			else:
#				motors.steering[k]=goal
#				motors.drive[k]=velocity
#		else:
#			if(motors.steering[k]-goal>pi/2):
 #                               motors.steering[k]=(-goal+pi)
 #                               motors.drive[k]=-velocity
 #                       elif(motors.steering[k]-goal<-pi/2 and motors.steering[k]-goal>-pi):
#                                motors.steering[k]=(-goal+pi)
 #                               motors.drive[k]=-velocity
#                        else:
#                                motors.steering[k]=-goal
#                                motors.drive[k]=velocity 
		
        return motors

    def integrate_odometry(self, motor_state, drive_cfg):
	self.currentTime = time.time()
	dt = self.currentTime - self.previousTime
        # The first time, we need to initialise the state
        if self.first_run:
            self.motor_state.copy(motor_state)
            self.first_run = False
            return self.X
        # Insert here your odometry code
	i=0
	for k in drive_cfg.keys():	
		self.A[i,:] = (1, 0, -drive_cfg[k].y)
		self.A[i+1,:] = (0, 1, drive_cfg[k].x)
	#	self.B[i,0] = (self.twist.linear.x-self.twist.angular.z*drive_cfg[k].y)*dt  
	#	self.B[i+1,0] = (self.twist.linear.y+self.twist.angular.z*drive_cfg[k].x)*dt
		self.B[i,0] = self.drem(motor_state.drive[k]-self.motor_state.drive[k],2*pi)*drive_cfg[k].radius*cos(self.motor_state.steering[k])
		self.B[i+1,0] = self.drem(motor_state.drive[k]-self.motor_state.drive[k],2*pi)*drive_cfg[k].radius*sin(self.motor_state.steering[k])
		i = i+2
	# motor_state : t = k*deltaT  self.motor_state : t = (k-1)*deltaT
	self.displacement = pinv(self.A)*self.B
	rospy.loginfo("displacement "+str(self.displacement))
    #    self.X[2,0] += self.displacement[2,0]
	
	#while(self.X[2,0]>pi):
	#	self.X[2,0]-= 2*pi
	#while(self.X[2,0]<-pi):
	#	self.X[2,0] += 2*pi
	rospy.loginfo("position "+str(self.X))
		#rotation for the world frame
	self.X[0,0] += self.displacement[0,0]*cos(self.X[2,0]) - self.displacement[1,0]*sin(self.X[2,0])
	self.X[1,0] += self.displacement[0,0]*sin(self.X[2,0]) + self.displacement[1,0]*cos(self.X[2,0])
	self.X[2,0] += self.displacement[2,0]
	#self.displacement[0,0]-self.displacement[0,0]*cos(self.X[2,0]) - self.displacement[1,0]*sin(self.X[2,0])
	#self.X[1,0] -= self.displacement[1,0]-self.displacement[0,0]*sin(self.X[2,0]) - self.displacement[1,0]*cos(self.X[2,0])
	#self.X[1,0] += self.displacement[1,0]
	self.motor_state.copy(motor_state)
	self.previousTime = self.currentTime
        return self.X
